# Questões:

1. O que é uma REST API?


> [!INFO] REST API (Representational State Transfer Application Programming Interface) é um conjunto de regras e convenções para criar e interagir com serviços web. Ela utiliza métodos HTTP (como GET, POST, PUT, DELETE) para realizar operações em recursos representados por URLs. A REST API é amplamente utilizada devido à sua simplicidade, escalabilidade e capacidade de ser consumida por diferentes tipos de clientes, como navegadores web e aplicativos móveis.
> Características de uma REST API:
> - Stateless: toda requisição deve conter as informações necessárias para o servidor processar. ou seja, não requer nenhum gerenciamento de sessões no server-side.
> - Interface uniforme: todas as requisições para o mesmo recurso devem ser iguais, independente de onde a requisição estiver vindo.
> - Client-Server: deve seguir o modelo Client-Server. onde cada cliente e servidor são completamente independentes. única interação entre eles devem ser através de requests e responses.
> - "Cacheável": Quando possível, as informações devem ser cacheáveis em ambos os lados tanto do cliente quanto do servidor.
> - Sistema em camadas: a API deve ser pensada de forma que nem o servidor nem o client saiba se está se comunicando com uma aplicação final ou um intermediário.

2. Para que serve o modelo publisher-subscriber?
> [!INFO] O modelo publisher-subscriber serve fundamentalmente para promover o desacoplamento e a comunicação assíncrona entre diferentes componentes de um sistema distribuído. Sua finalidade é permitir que um componente (o publisher) anuncie informações sobre um evento sem precisar conhecer a identidade, a quantidade ou o estado dos componentes (os subscribers) que consumirão essa informação. 
	
3. Qual tecnologia usaremos para pub-sub (ex.: WebSockets, MQTT, NATS)?
> [!INFO] A escolha pelo MQTT (Message Queuing Telemetry Transport) pode ser justificada por ele ser um protocolo projetado para ser extremamente leve e eficiente em termos de banda, o que o torna uma opção interessante para cenários com redes instáveis ou dispositivos com recursos computacionais limitados. Além disso, ele oferece mecanismos de Qualidade de Serviço (QoS) que permitem configurar diferentes níveis de garantia na entrega de mensagens, um recurso importante para lidar com a perda de pacotes.

4. O que é um “tópico/canal” no pub-sub e como vamos nomeá-los?
> [!INFO] Em um modelo pub-sub, um tópico ou canal é um endereço lógico ou um rótulo que atua como intermediário para a distribuição de mensagens. Ele funciona como uma categoria para a qual os publishers enviam suas mensagens. Os subscribers, por sua vez, registram seu interesse em um ou mais tópicos específicos para receber apenas as mensagens que lhes são relevantes.

5. Como os clientes se autenticam/entram no jogo?
> [!INFO] A autenticação dos clientes pode ser realizada através de um sistema de login que utiliza tokens JWT (JSON Web Tokens). Quando um usuário se registra ou faz login, o servidor gera um token JWT que contém informações sobre o usuário e suas permissões. Esse token é então enviado ao cliente, que deve incluí-lo em todas as requisições subsequentes para autenticar sua identidade. O servidor valida o token em cada requisição para garantir que o usuário está autorizado a acessar os recursos solicitados.

6. Como vamos identificar cada partida (ID da partida)?
> [!INFO] Cada partida pode ser identificada por um UUID (Universally Unique Identifier) gerado no momento da criação da partida. O UUID é um identificador único que garante que cada partida tenha um ID distinto, mesmo em sistemas distribuídos. Esse ID pode ser usado para rastrear o estado da partida, os jogadores envolvidos e outras informações relevantes ao longo do ciclo de vida do jogo.

7. Qual será o formato das mensagens (ex.: JSON) e quais campos mínimos precisam existir?

> [!INFO] O formato das mensagens será JSON (JavaScript Object Notation) devido à sua simplicidade, legibilidade e ampla compatibilidade com diversas linguagens de programação. Os campos mínimos que precisam existir em cada mensagem incluem:
> - message_type: Indica o tipo de mensagem (ex.: "join_game", "play_card", "game_state").
> - match_id: Identificador único da partida.
> - player_id: Identificador único do jogador que está enviando a mensagem.
> - timestamp: Marca temporal indicando quando a mensagem foi enviada.
> - payload: Um objeto que contém os dados específicos da mensagem, como a carta jogada ou o estado atual do jogo.  

8. O que é idempotência e como evitamos processar a mesma ação duas vezes?
> [!INFO] Idempotência é uma propriedade de certas operações que permite que elas sejam executadas múltiplas vezes sem alterar o resultado além da primeira aplicação. Em outras palavras, uma operação idempotente pode ser repetida várias vezes com o mesmo efeito, sem causar efeitos colaterais adicionais. Para evitar processar a mesma ação duas vezes, podemos implementar mecanismos como:
> - Uso de identificadores únicos para cada ação (ex.: request_id) que permitem ao servidor reconhecer e ignorar ações duplicadas.
> - Armazenamento do estado das ações já processadas em um banco de dados, para que o servidor possa verificar se uma ação já foi executada antes de processá-la novamente.
> - Implementação de locks ou semáforos para garantir que uma ação específica só possa ser processada por um único servidor ou thread de cada vez.  

9. Como evitar que dois servidores entreguem o mesmo pacote de cartas para pessoas diferentes?
> [!INFO] Para evitar que dois servidores entreguem o mesmo pacote de cartas para pessoas diferentes, podemos implementar um sistema de coordenação centralizado ou distribuído que gerencie a alocação dos pacotes de cartas. Algumas estratégias incluem:
> - Utilização de um banco de dados ou sistema de cache compartilhado para rastrear quais pacotes de cartas já foram entregues e a quem.
> - Implementação de um mecanismo de locking distribuído, onde um servidor deve adquirir um lock antes de entregar um pacote de cartas, garantindo que apenas um servidor possa entregar um pacote específico de cartas por vez.
> - Uso de filas de mensagens para gerenciar a distribuição dos pacotes de cartas, onde cada servidor consome mensagens da fila e processa a entrega de cartas de forma ordenada e controlada.

10. O que acontece se um servidor cair no meio da partida? Como retomamos?
> [!INFO] Se um servidor cair no meio da partida, podemos implementar um mecanismo de failover e recuperação para garantir que a partida possa ser retomada sem perda de dados ou interrupção significativa. Algumas estratégias incluem:
> - Replicação de estado: Manter uma cópia do estado da partida em um banco de dados ou sistema de cache compartilhado, permitindo que outro servidor possa assumir a partida a partir do último estado conhecido.
> - Monitoramento e detecção de falhas: Implementar um sistema de monitoramento que detecte rapidamente quando um servidor cai e notifique outros servidores ou componentes do sistema.
> - Redistribuição automática: Configurar o sistema para que, ao detectar a falha de um servidor, outro servidor possa automaticamente assumir a responsabilidade pela partida e continuar o jogo a partir do último estado salvo.
> - Notificação aos jogadores: Informar os jogadores sobre a falha do servidor e o processo de retomada, garantindo transparência e mantendo a confiança dos usuários.

11. Como os servidores “se encontram” (lista fixa, descoberta simples, heartbeat)?

> [!INFO] Os servidores podem se encontrar utilizando um mecanismo de descoberta simples baseado em um serviço de registro centralizado. Esse serviço atua como um diretório onde os servidores se registram ao iniciar e atualizam seu status periodicamente através de heartbeats. O processo pode ser descrito da seguinte forma:
> - Registro: Cada servidor, ao iniciar, se registra no serviço de registro centralizado, fornecendo informações como seu endereço IP, porta e capacidade.
> - Heartbeat: Os servidores enviam mensagens de heartbeat em intervalos regulares para o serviço de registro, indicando que estão ativos e disponíveis para comunicação.
> - Descoberta: Quando um servidor precisa se comunicar com outro, ele consulta o serviço de registro para obter a lista atualizada de servidores ativos e suas informações de conexão.

12. Que logs básicos precisamos (ex.: match_id , request_id ) para entender
problemas?

> [!INFO] Para entender problemas em um sistema distribuído, é essencial coletar logs que forneçam informações detalhadas sobre as operações e eventos que ocorrem. Alguns logs básicos que precisamos incluir são:
> - match_id: Identificador único da partida, para rastrear eventos específicos relacionados a uma partida.
> - request_id: Identificador único para cada requisição, permitindo rastrear o fluxo de uma ação específica através do sistema.
> - timestamp: Marca temporal indicando quando o evento ocorreu, para ajudar na análise cronológica dos eventos.
> - player_id: Identificador do jogador envolvido no evento, para entender o contexto das ações.
> - event_type: Tipo de evento (ex.: "join_game", "play_card", "error"), para categorizar os logs.
> - message: Descrição detalhada do evento ou erro, para fornecer contexto adicional.
> - server_id: Identificador do servidor que processou a ação, para rastrear problemas específicos de servidores.
> - status_code: Código de status da operação (ex.: sucesso, falha), para facilitar a análise de erros.

13. O que é um sistema distribuído e como funciona?
> [!INFO] Um sistema distribuído é um conjunto de computadores independentes que aparecem para os usuários como um sistema único e coerente. Esses computadores, ou nós, trabalham juntos para alcançar um objetivo comum, compartilhando recursos e informações através de uma rede. A principal característica de um sistema distribuído é a distribuição de tarefas e dados entre múltiplos nós, o que pode melhorar a escalabilidade, a disponibilidade e a tolerância a falhas do sistema.
> Funcionamento de um sistema distribuído:
> - Comunicação: Os nós em um sistema distribuído se comunicam entre si através de mensagens, utilizando protocolos de rede para trocar informações e coordenar ações.
> - Coordenação: Os nós precisam coordenar suas atividades para garantir que as operações sejam realizadas de forma consistente e eficiente. Isso pode envolver a sincronização de dados, a gestão de transações e a resolução de conflitos.
> - Tolerância a falhas: Sistemas distribuídos são projetados para continuar funcionando mesmo quando alguns nós falham. Isso é alcançado através de mecanismos como replicação de dados, detecção de falhas e recuperação automática.
> - Escalabilidade: Sistemas distribuídos podem ser facilmente escalados adicionando mais nós à rede, permitindo que o sistema lide com um aumento na carga de trabalho sem comprometer o desempenho.
